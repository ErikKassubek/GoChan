package main

import (
	"fmt"
	"math/rand"
	"os/exec"
	"os"
	"reflect"
	"time"
	"strings"
)

var max_runs = 50  // max number of runs 
var no_failed = 10  // max number of already checked orders

var switch_size = make(map[int]int) // id -> size
var queue = make([]map[int]int, 0)  // already tested orders

var messages = make(map[string][]string, 0)  // collect result messages message -> switch orders

/*
Get a string from a switch order
@param soe map[int]int: order
@return string: string representing the switch order
*/
func toString(soe map[int]int) string {
	res := ""
	i := 0
	for key, c := range soe {
		res += fmt.Sprint(key) + "," + fmt.Sprint(c)
		if i != len(soe)-1 {
			res += ";"
		}
		i++
	}
	return res
}

/*
Main function
*/
func main() {
	$$SWITCH_SIZE$$

	rand.Seed(time.Now().UTC().UnixNano())

	fmt.Println("Determine switch execution order")

	for no_failed > 0  && max_runs > 0 {
		order_add := make(map[int]int)
		for key, size := range switch_size {
			order_add[key] = rand.Intn(size)
		}
		if wasNotInQueue(order_add) {
			queue = append(queue, order_add)
		} else {
			no_failed -= 1
		}	
		max_runs -= 1
	}

	fmt.Println("Start Program Analysis")

	var i float32 = 0
	max := float32(len(queue))

	for len(queue) != 0 {

		order := queue[0]
		queue = queue[1:]

		orderString := toString(order)
		
		percent := int(i / max * 100.)
		fmt.Printf("Analyse Program: %3d%%   %s\n", percent, orderString)
		i++


		var cmd *exec.Cmd
		if len(order) == 0 {
			cmd = exec.Command("$$COMMAND$$")
		} else {
			cmd = exec.Command("$$COMMAND$$", "-order=\"" + orderString + "\"")
		}

		out, err := cmd.Output()
		if err != nil {
			if fmt.Sprint(err) == "exit status 42" {
				fmt.Println("Runtime exceeded limit")
				continue
			}
    	fmt.Println(fmt.Sprint(err))
			if strings.HasPrefix(fmt.Sprint(err), "fork/exec") || strings.HasSuffix(fmt.Sprint(err), "no such file or directory") {
				fmt.Println("Most likely cause:\nThe EXEC value was not set correctly during the instrumentation.\nIt should be the name " +
					"of the executable created when compiling the original code.")
				fmt.Println("Abort Analysis")
				os.Exit(1)
			}
    	continue
		}

		output := string(out)

		for _, message := range strings.Split(output, "\n\n") {
			if message == "" {
				continue
			}
			if _, ok := messages[message]; !ok {
				messages[message] = make([]string, 0)
			}
			messages[message] = append(messages[message], orderString)
		}
	}

	fmt.Println("Analyse Program: 100%\n")
	fmt.Println("Finish Analysis\n")

	l := len(messages)
	if l == 0 {
		fmt.Println("No Problems Found")
	} else {
		fmt.Println("Found Problems:\n")
		for message, orders := range messages {
			if len(orders) != 0 && len(message) != 0 && orders[0] != "" {
				fmt.Print("Found problem while examine the following orders: ")
				for _, order := range orders {
					fmt.Print("  ", order)
				}
				fmt.Print("\n")
			}
			fmt.Println(message)
			fmt.Print("\n")
		}
	}
}

/*
Check if an order was not inserted into the queue before
@param order map[int]int: map representing an order
@return bool: true, if the order was not in the queue before, false otherwise
*/
func wasNotInQueue(order map[int]int) bool {
	for _, i := range queue {
		if reflect.DeepEqual(i, order) {
			return false
		}
	}
	return true
}