package main

import (
	"fmt"
	"math/rand"
	"os/exec"
	"os"
	"reflect"
	"time"
	"strings"
)

var max_runs = 20  // max number of runs 
var no_failed = 7  // max number of already checked orders

var switch_size = make(map[int]int) // id -> size
var queue = make([]map[int]int, 0)  // already tested orders

var messages = make(map[string][]string, 0)  // collect result messages message -> switch orders

/*
Get a string from a switch order
@param soe map[int]int: order
@return string: string representing the switch order
*/
func toString(soe map[int]int) string {
	res := ""
	i := 0
	for key, c := range soe {
		res += fmt.Sprint(key) + "," + fmt.Sprint(c)
		if i != len(soe)-1 {
			res += ";"
		}
		i++
	}
	return res
}

/*
Main function
*/
func main() {
	$$SWITCH_SIZE$$

	rand.Seed(time.Now().UTC().UnixNano())

	fmt.Println("Determine switch execution order")

	for no_failed > 0  && max_runs > 0 {
		order_add := make(map[int]int)
		for key, size := range switch_size {
			order_add[key] = rand.Intn(size)
		}
		if wasNotInQueue(order_add) {
			queue = append(queue, order_add)
		} else {
			no_failed -= 1
		}	
		max_runs -= 1
	}

	fmt.Println("Start Program Analysis")

	var i float32 = 0
	max := float32(len(queue))

	failed := false

	for len(queue) != 0 {
		order := queue[0]
		queue = queue[1:]

		orderString := toString(order)
		
		percent := int(i / max * 100.)
		fmt.Printf("Analyse Program: %3d%%   %s\n", percent, orderString)
		i++


		var cmd *exec.Cmd
		if len(order) == 0 {
			cmd = exec.Command("$$COMMAND$$")
		} else {
			cmd = exec.Command("$$COMMAND$$", orderString)
		}

		out, err := cmd.CombinedOutput()
		if err != nil {
			if fmt.Sprint(err) == "exit status 42" {
				fmt.Println("Runtime exceeded limit")
			} else {
				failed = true
				fmt.Println(fmt.Sprint(err.Error()))
				if strings.HasPrefix(fmt.Sprint(err), "fork/exec") || strings.HasSuffix(fmt.Sprint(err), "no such file or directory") {
					fmt.Println("\nProgram could not be started\n\nPossible cause:\n   - The EXEC value was not set correctly during the instrumentation.\n     It should be the name " +
						"of the executable created when compiling the original code.\n   - The Program rased an error during compile time.\n\n")
					fmt.Println("Abort Analysis")
					os.Exit(1)
				}
			}
		}

		output := string(out)

		start := false
		if !strings.HasPrefix(output, "##@@##") {
			start = true
		}

		for i, message := range strings.Split(output, "##@@##") {
			if len(strings.TrimSpace(message)) == 0 {
				continue
			}
			if strings.Contains(message, "panic: send on closed channel") {
				m_split := strings.Split(message, "\n")
				message = "Send on closed channel:\n    " + m_split[len(m_split)-2]
			}
			if start && i == 0 {
				continue
			}
			if _, ok := messages[message]; !ok {
				messages[message] = make([]string, 0)
			}

			if !isInList(messages[message], orderString) {
				messages[message] = append(messages[message], orderString)
			}
		}
	}

	fmt.Println("Analyse Program: 100%\n")
	fmt.Println("Finish Analysis\n")

	if failed {
		fmt.Println("At least on of the runs failed!\n")
	}

	l := len(messages)
	if l == 0 && !failed {
		fmt.Println("No Problems Found")
	} else if l > 0 {
		fmt.Println("Found Problems:\n")
		for message, orders := range messages {
			if len(orders) != 0 && len(message) != 0 && strings.TrimSpace(orders[0]) != "" {
				fmt.Print("Found problem while examine the following orders: ")
				for _, order := range orders {
					fmt.Print("  ", order)
				}
				fmt.Print("\n")
			}
			fmt.Println(message)
			fmt.Print("\n")
		}
	}
}

/*
Check if an order was not inserted into the queue before
@param order map[int]int: map representing an order
@return bool: true, if the order was not in the queue before, false otherwise
*/
func wasNotInQueue(order map[int]int) bool {
	for _, i := range queue {
		if reflect.DeepEqual(i, order) {
			return false
		}
	}
	return true
}

/*
Check if elem is in list
@return bool: true if elem is in list, false otherwise
*/
func isInList(list []string, elem string) bool {
	for _, e := range list {
		if e == elem {
			return true
		}
	}
	return false
}